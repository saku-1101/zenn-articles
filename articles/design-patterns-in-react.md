---
title: "Reactのデザインパターンを知る"
emoji: "🎨"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "javascript"]
published: false
# published_at: 2023-12-10 10:00 # 未来の日時を指定する
---

※ この記事は [Cybozu Frontend Advent Calendar 2023](https://adventar.org/calendars/9255) の 10 日目の記事です !

私の所属する Reactone チームでは，React を用いて kintone のフロントエンド刷新を行なっています．
内定者アルバイトとしてチームにジョインしたことが私の初めての実務経験で，抽象化された見慣れないモジュールの数々の読解に時間がかかってしまいました．
React はリユーザブルなコンポーネントや拡張性のあるエコシステムのおかげで，多くの開発者に使用されるライブラリとなっていますが，それだけではなく，React のデザインパターンを適切に使用することで開発プロセスが格段に効率よくなるものだと感じています．
その「デザインパターン」というものが，Reactone チームのコードベースでは適切に組み込まれたり改良されたりしており，保守・運用性や再利用性の高いフロントエンド刷新を支えてくれています．
そこで今回は，私が内定者としてお仕事をする前に知っておきたかった React のデザインパターンについてお話ししていこうと思います．

## React におけるデザインパターンのイントロ

デザインパターンの詳細に入る前に，「デザインパターンとは何なのか？」「どうしてデザインパターンが必要とされているのか？」というのを理解しておきたいです👀

デザインパターンの基本的な役割としては，開発する上で起こる問題に対してのテンプレート・共通の解決策となることです．
デザインパターンは開発の上で起こるある特定の問題を解決するための専門性を持ったモジュール群やパターンで，開発にかかる時間を大きく節約してくれたり，共通の認識が取れていればコードの可読性をあげたり，メンテナンスしやすくしてくれます．

早速，具体的なデザインパターンの例を見ていきましょう．

## カスタム Hooks
React Hooks は今となっては当たり前の`state`やライフサイクルメソッド(`useEffect`, `useContext`etc......)などの React の概念にシンプルにアクセスできる方法を提供してくれています．
そんなReact Hooksで書かれたロジックが，あるコンポーネントと別のコンポーネントでも必要になった時，カスタムHooksが効果を発揮します．

たとえば，localStorageを複数のコンポーネントから操作したいとします．
⭐️
ProductGalleryとProductListで同じコードを書いても確かに結果としては同じなのですが，冗長さや再利用性，メンテナンス性のことを考えると避けたい方法です．
その代わりに，例のようにロジックを`useLocalStorage` というカスタムHooksに切り出して，localStorageを操作する箇所をカスタムHooksに集約させることができます．これで，localStorageに変更を加えるときはProductGalleryもProductListも`useLocalStorage`を使用すれば良くなります．

もちろんlocalStorage以外にも，カスタムHooksを使うと便利な側面はたくさんあって，
- データフェッチをするとき
- windowにアクセスするとき
- 複数のコンポーネント間で`state`の切り替えをするとき
など，**ある特定の操作対象に複数の要素からアクセスを試みる場合**は，特にカスタムHooksの効果が発揮されます．

## Provider パターン
次にProviderパターンについて理解していきます．

Reactを使用する際によく直面する問題として，Propsのバケツリレー([Props Drilling]())があります．
Props Drillingとは`props`(data)がそのデータが必要なコンポーネントに至るまでコンポーネント間を渡り続けることで起こる現象です．
一般的に，Props Drillingが起こるとよくないと言われている理由は，コンポーネントツリーでデータチェーンができてしまい，データによるコンポーネント間の依存関係ができてしまうからです．

この問題の解決策の一つとして，Providerパターンが挙げられます．Providerパターンにより，データを管理する役割を持ったContext Providerがネスト内の他のコンポーネントを介さずにデータが必要なコンポーネントに**直接データを渡すことができます**．

Reactはこのデザインパターンのための組み込みのContext APIを保持しており，Fluxパターンの実現や，他にも有名なサードパーティのライブラリRedux, Recoilなどもこのパターンを内部的に使用しています．

実際にコードを見ながらProviderパターンを理解してみましょう🤸🏻‍♀️
まず，`useContext`を使用せずにアプリのlight/darkモードを変えてみます．
⭐️
次に，Reactの提供するContext Providerの仕組みを使用してみるとどうなるでしょうか？
⭐️

## Compoundコンポーネントパターン
Compoundコンポーネントパターンは，複数のコンポーネントがstateやロジックを共有する際に便利です．

例として，Tabの実装を考えてみます．
Tabを構成するためのコンポーネントとして，大きくTabバーと内容を表示する部分があります．
※以下のようなTabの構成を想定します．

Tabを実装するには，内容表示部分がどの値がTabバーで選択されたのか知っておく必要があります．これは複数のコンポーネント間でstateが共有された状態であるといえます．Compoundコンポーネントパターンが使えそうです！

Compoundコンポーネントパターンで実装してみましょう．
⭐️

他にも，このパターンで
- n-1個以上のボタンがToggleできないトグルボタン(n = all)
- n-1個以上の要素がひらけないアコーディオン
- n-1個以上の要素がひらけないメニューバー
などの実装に使えそうです．

## 高階コンポーネント(HOC)パターン
高階コンポーネントパターンの前に，「高階」とはどういった意味なのでしょうか？😶

高階コンポーネントパターンでは，アプリケーション全体で再利用可能なロジックをpropsからコンポーネントに渡すことができます．
具体的には，高階コンポーネントパターンを実現する高階コンポーネント(HOCs)は純関数で，コンポーネントを引数にとり，さらに手の加えられた新たなコンポーエントを返します．

説明だけではわかりにくいと思うので，高階コンポーネントパターンを利用して複数のコンポーネントを作ってみましょう．
デモアプリケーションでは，アプリケーション全体の仕様として
- loading状態 => Wait for a sec...⏳
- error状態 => Sorry, data could not be fetched.🥲
- !data状態 => No data was found.☹️
を表示するということが決まっているとします．

もし，この処理を個々のコンポーネントで行うとなると次のようになります．
⭐️
これだと，
⭐️行目
の処理をデータフェッチを行うすべてのコンポーネントで書くことになってしまいます．

ここでHOCsを使用してみましょう．
⭐️

`withFetchingState`HOCを通して，アプリケーションの仕様を共通化して再利用できました🌟

このように，HOCsはアプリケーションを通して横断的な関心ごとにまとめて対応するとき特に有効です．

さらに，高階コンポーネントは**合成**することもできます．
たとえば，ユーザが要素をホバーしたときにbackGroundとcolorのstyleを変更する機能を追加したいとします．
これを`withHoverState`HOCを用いて実現すると，以下のようになります．
⭐️

ReactがCompositionalであるという特徴を活用しているHOCパターンをうまく利用することでコードを[DRY]()に保つことができていますね！

とはいえ，HOC パターンをカスタムHooksで置き換えることができる場合もあります．
上記の例をカスタムHooksで実現するにはカスタムHooks内でのDOMの操作が必要になってきますが，[前バージョンReactの公式ドキュメント](https://ja.legacy.reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)にもあるように，フックを使うことで大抵の場合はカバーできそうです．

## Presentational&Containerコンポーネントパターン
名前の通り，このパターンではコンポーネントの役割をPresentationalとContainerという２つのカテゴリーで分けて考えます．
- Container Components: データの管理をするコンポーネント．**自身がラップする**Presentation Componentsに必要なデータを受け渡す責務．
- Presentation Components: データContainer Componentsから取得し，表示するコンポーネント．受け取ったデータを**変更することなく**期待通りに表示する責務．

Presentational&Containerコンポーネントパターンは[Reactにおける関心の分離]()を実現する方法の一つとして広く知られています．
このパターンにより，ビュー(Presentation)をロジック(Container)から分離することができます．

例として，画像を表示するカードUIコンポーネントを作成してみましょう．


⭐️azukiazusaさんの記事

しかし，Containerコンポーネントを使用する代わりに，先にお話ししたカスタムHooksを使用することによって，Containerコンポーネントという余分なレイヤーを省くことができることもあります．カスタムHooksを導入することにより，Containerコンポーネントを必要とせずに，Presentationコンポーネントをステートフルにできます．
⭐️

## Render Prop パターン
Render Propパターンについて理解してきます．
一般的に，レンダープロップというと**JSX(TSX)を返却する関数**を値とするpropsのことを指します．Render Propパターンのコンポーネントは，propsとしてJSX(TSX)を返す関数をとり，その関数を自身のレンダリングロジック(returnでJSX(TSX)をレンダリング)を用いる代わりに呼び出すことでレンダリングを行います．つまり，render propsを用いて**何をレンダリングするかを外側から決定できます**．

例を用いて確認していきます🧗🏻‍♀️
xxのデータを取得し，表示するProductGalleryとProductListがあります．ProductGalleryでは画像だけの表示，ProductListでは詳細を表示したいです．使用するロジックは一緒で，表示方法が異なります．
Render Propsパターンを使って，外側のコンポーネントからProductGalleryとProductListがそれぞれ何を表示すべきか決定してあげましょう．

このように，GalleryとListそれぞれで値取得のロジックを書かなくても，ProductGalleryとProductListがレンダリングすべきもの自体を`props`として注入してあげることで適切にレンダリングができるようになりました．

<!-- Render Propパターンは実はHOCパターンと似通っていて，アプリケーションを通して横断的な関心ごとにまとめて対応することができます． -->

## まとめ
